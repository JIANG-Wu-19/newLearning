每次调用 `fork()` 都会将当前进程复制一份。因此：

1. 第一次 `fork()` 后，进程数变为 2。
2. 第二次 `fork()` 后，进程数变为 4。
3. 第三次 `fork()` 后，进程数变为 8。

每个进程都会执行 `printf("OS ");`，所以总共会打印 8 次 “OS”。

`"OS"` 会被打印 5 次。

**解释：**

1. **第一次 `fork()`：**
   * 创建两个进程：父进程 A 和子进程 B。
2. **在父进程 A 中：**
   * 第一个 `fork()` 返回子进程 B 的 PID（非零），条件 `fork() || fork()` 为真。
   * 执行第三个 `fork()`，创建子进程 C。
3. **在子进程 B 中：**
   * 第一个 `fork()` 返回 `0`，条件 `fork() || fork()` 取决于第二个 `fork()` 的结果。
   * 执行第二个 `fork()`，创建子进程 D。
4. **在子进程 D 中：**
   * 第二个 `fork()` 返回 `0`，条件 `fork() || fork()` 为假，不执行第三个 `fork()`。
5. **在父进程 A 和子进程 C 中：**
   * 都执行 `printf("OS ");`。
6. **在子进程 B 中：**
   * 条件为真，执行第三个 `fork()`，创建子进程 E，并执行 `printf("OS ");`。
7. **最终执行 `printf("OS ");` 的进程：**
   * A、C、B、E 和 D，共 5 个进程。

因此，总共会打印 5 次 `"OS"`。

* **流设备和块设备表现相同** ：通过内核缓冲区，流设备（如网络接口）和块设备（如硬盘）在使用上没有区别，统一管理数据传输。
* **读取操作会阻塞进程，处理器可执行其他任务** ：当进程发起读取请求时，如果数据尚未准备好，读取操作会阻塞该进程，允许处理器切换到其他任务，提高系统效率。
* **写入操作不会阻塞，即使写入速度快于设备接收速度** ：写入数据被先存入内核缓冲区后立即返回，即使实际设备处理数据速度较慢，写入操作本身不会阻塞进程，提升写入性能。



## 系统调用存根

* **定义** ：系统调用存根是一组在用户空间实现的函数，用于封装和简化对内核系统调用的访问。它们充当用户应用程序与操作系统内核之间的中介，提供一致的接口来执行各种系统级操作。
* **工作原理** ：

1. **封装系统调用** ：存根函数封装了具体的系统调用指令，使得用户程序无需直接使用复杂的低级指令即可调用内核服务。
2. **参数传递** ：通过存根函数，用户程序可以将参数传递给内核，例如文件描述符、缓冲区地址等。
3. **上下文切换** ：存根函数负责触发从用户模式到内核模式的上下文切换，以执行系统调用。
4. **返回结果** ：系统调用完成后，存根函数将结果返回给用户程序，并处理可能的错误码。
